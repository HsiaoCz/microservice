## 分布式锁

为什么需要分布式锁
比如用户下单，我们需要锁住uid防止重复下单
比如库存扣减，要锁住库存，防止超卖
比如余额扣减，锁住账户，防止并发操作

在分布式系统中同一个资源往往需要分布式锁来保证变更资源的一致性

分布式锁需要具备哪些特性:
1、排他性：
锁的基本特性，并且只能被第一个持有者持有
2、防死锁
高并发场景下临界资源一旦发生死锁非常难以排查，通常可以设置超时时间到期自动释放锁来规避
3、可重入
持有者支持可重入，防止锁持有者再次重入锁时被释放
4、高性能高可用
锁是代码运行的关键前置节点，一旦不可用则业务直接报故障了，高并发场景下，高性能高可用是基础要求

### 1、单机并发的锁

在单机程序并发修改全局变量的时候，需要加锁以创建临界区

```go
// 全局变量
var counter int
var wg sync.WaitGroup
var lock sync.Mutex

func main() {
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			lock.Lock()
			counter++
			lock.Unlock()
		}()
	}
	wg.Wait()
	fmt.Println(counter)
}

// 并发访问资源 如果不加锁，每次都会得到不一样的结果
// 想要的到正确的结果就需要加锁
```

之前的例子 我们使用lock来加锁
如果在某些场景下，我们需要一个任务有单一的执行者，而不是像计数场景那样，所有的goroutine都执行成功，我们需要后来的groutine在抢锁失败之后，自动放弃流程，这时候就需要trylock

trylock:尝试加锁，加锁成功后执行后续流程，如果加锁失败的话也不会阻塞，而是直接返回加锁的结果
