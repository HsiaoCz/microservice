## 幂等性机制

服务雪崩;

服务雪崩效应是一种因"服务提供者的不可以用"，导致"服务调用者的不可用"(结果)，
并将这种不可用不断放大的现象

这种现象的产生主要是服务之间的互相调用导致的，其中一个服务挂掉了，
它作为服务的提供方，调用它的服务也会挂掉，挂掉的这个服务调用者也可能是其他服务的提供者，
调用它的也会挂掉，从而产生雪崩。

所以为了避免产生雪崩，我们对请求要有超时机制
超时机制：超过一定的响应时间就返回，避免一直不返回造成雪崩

### 超时、重试和幂等性机制

超时：
   超时是为了保护服务，避免服务调用者因为服务提供方响应慢而变得很慢，这样服务调用方可以尽可能地保持原有地性能

重试：
   如果服务地提供方只是偶尔地抖动，那么超时之后直接放弃，不做后续地处理，就会导致当前请求错误，也会带来业务方面的损失
   对于这种偶尔地抖动，可以在超时之后重试一下，重试如果正常返回了，那么这次请求就被挽救了，能够正常给前端返回数据，只不过比原来响应慢一些，重试可以考虑切换一台机器来进行调试，因为原来机器可能由于临时负载高而性能下降，重试会加剧其性能问题，而换一台机器，得到更快返回地概率也更大一些

幂等：
   如果允许服务调用者重试，那么服务提供方就要能够做到幂等，同一个请求被服务调用方多次调用，对服务地提供方产生地影响是一致地，而且这个幂等应该是服务级别地，而不是某台机器层面地，重试调用任何一台机器，都应该做到幂等

那什么是幂等性：
每一个接口都需要处理用户请求
所谓地幂等性就是要求同样地数据，因为重试机制调用了多次，但是数据库中只能存在一份

哪些情况下需要考虑幂等性：
    1.http请求：
        get请求，获取信息的，无所谓的
        post请求，比较常见，产生数据的变化的，需要考虑幂等性
        put请求，不一定需要考虑幂等，put请求是对数据的局部更改，比如把商品的价格改为200，就不需要考虑幂等性
        但是，如果是把商品的价格加1，就需要考虑幂等性了，因为如果出现重试机制，可能会多次修改
        delete:一般也无所谓

### grpc的重试机制

// 这里面需要考虑这样几点，这个请求应该多长时间超时，这个重试应该几次，当服务器返回什么状态码的时候重试

```go

```

### 解决幂等性机制

如何保证接口的幂等性？

1、唯一索引的方式，可以防止新增脏数据
比如新建用户的时候将手机号码设置为唯一索引，那么即使你重试，也只会创建一个用户，不会因为网络抖动创建两个用户

要点：
唯一索引或唯一组合索引防止新增数据存在脏数据
当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可

2、token机制，防止页面重复提交
业务要求：
   页面的数据只能被点击提交一次
发生原因：
   重复点击提交或者网络重发，或者nginx重发等情况会导致数据被重复提交
解决办法：
   集群环境：采用token加redis(redis单线程的，处理需要排队)
处理流程：
   提交数据前申请token，token放到redis或内存，token有效时间
   提交后后台校验token，同时删除token,生成新的token返回

   token特点：
   要申请，一次有效性，可以限流

3、悲观锁
获取数据的时候加锁获取，不过这样做性能极大的降低
悲观锁伴随事物一起使用，数据锁定时间可能很长，根据实际情况选用

4、乐观锁

乐观锁只在更新数据的那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高

5、分布式锁

6、select+insert

并发不高的后台系统，为了支持幂等，支持重复执行，简单的处理方法是，先查询一些关键的数据
判断一下是不是已经处理过了

7、对外提供接口的api如何保证幂等性？

如银联提供的支付接口，需要接入商户提交付款请求时附带：source来源，seq序列号，这两个在数据库里面做唯一索引，防止多次付款

重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源序列号seq,这两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理，返回相应的处理结果，没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否已经处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了

### 关于幂等

幂等不一定就非得是高并发或者是分布式
有一些操作一定要考虑幂等性